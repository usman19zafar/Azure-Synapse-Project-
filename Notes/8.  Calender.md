LECTURE NOTES — Calendar.csv (Theory + Code Integrated)

A boundary‑document version, rewritten for clarity, mastery, and mechanical understanding.

1. Switching to the Correct Database

Theory:  
Every serverless SQL script must explicitly switch to the correct database.
This ensures your external data sources and file references resolve correctly.

Code:

```sql
USE [NYCTaxi_Discovery];
```
******************************************************************************************************************************************

2. Reading the File Using OPENROWSET (No WITH Clause)

Theory:  
Start with a raw exploration query.
This helps you confirm:

the file path

the external data source

the parser version

whether the header is detected

whether the file loads successfully

This is your first contact with the data.

Code:
```
sql
SELECT *
FROM OPENROWSET(
    BULK 'calendar.csv',
    DATA_SOURCE = 'NYC_Taxi_Data_RAS',
    FORMAT = 'CSV',
    PARSER_VERSION = '2.0',
    HEADER_ROW = TRUE
) AS CalendarData;
```

******************************************************************************************************************************************
3. Understanding Why WITH Clause Matters
Theory:  
Without a WITH clause:

all strings become VARCHAR(8000)

all numbers become BIGINT

performance decreases

cost increases

schema inference becomes unpredictable

For repeated use, always define a WITH clause.


******************************************************************************************************************************************
4. Defining the Schema Using WITH Clause
Theory:  
This is where you explicitly control:

column names

data types

memory footprint

performance characteristics

This transforms the file from “raw CSV” into a structured table‑like object.

Code:
```
sql
SELECT *
FROM OPENROWSET(
    BULK 'calendar.csv',
    DATA_SOURCE = 'NYC_Taxi_Data_RAS',
    FORMAT = 'CSV',
    PARSER_VERSION = '2.0',
    HEADER_ROW = TRUE
)
WITH (
    DateKey        INT,
    DateValue      DATE,
    YearValue      SMALLINT,
    MonthValue     TINYINT,
    DayValue       TINYINT,
    DayOfWeek      TINYINT,
    DayName        CHAR(10),
    MonthName      CHAR(10)
) AS CalendarData;
```

******************************************************************************************************************************************
5. Data Type Selection Logic
Theory:  
Use the smallest type that fits the data.
This is a core Data Architect skill.

TINYINT → 0–255 (day, month)

SMALLINT → year

INT → date keys

CHAR(n) → fixed‑length names

DATE → actual date values

This reduces cost and improves performance.

(No code here — this is conceptual.)


******************************************************************************************************************************************
6. Ordinal Access (Advanced Technique)
Theory:  
If you remove the header row, Synapse cannot infer column names.
You must reference columns by position (c1, c2, etc.).
This is useful when:

the header is missing

the header is corrupted

you want full manual control

Code:

```sql
SELECT
    c1 AS DateKey,
    c2 AS DateValue,
    c3 AS YearValue,
    c4 AS MonthValue,
    c5 AS DayValue,
    c6 AS DayOfWeek,
    c7 AS DayName,
    c8 AS MonthName
FROM OPENROWSET(
    BULK 'calendar.csv',
    DATA_SOURCE = 'NYC_Taxi_Data_RAS',
    FORMAT = 'CSV',
    PARSER_VERSION = '2.0',
    HEADER_ROW = FALSE,
    FIRSTROW = 2
)
WITH (
    c1 INT,
    c2 DATE,
    c3 SMALLINT,
    c4 TINYINT,
    c5 TINYINT,
    c6 TINYINT,
    c7 CHAR(10),
    c8 CHAR(10)
) AS CalendarData;
```

******************************************************************************************************************************************
7. Why This File Matters (Analytical Theory)
Theory:  
The calendar file becomes a Date Dimension, enabling:

weekday vs weekend analysis

seasonal trends

month‑over‑month comparisons

day‑of‑week performance

time‑series grouping

This is essential for joining with trip data later.

(No code — conceptual.)


******************************************************************************************************************************************
8. Summary (Boundary‑Document Closure)
You now have:

theory → code

concept → demonstration

architecture → implementation

This is exactly how a boundary document should function:
it captures the edge between instruction and mastery.
