How Serverless SQL Reads Different JSON Formats
Serverless SQL cannot directly parse JSON the way it parses CSV or Parquet.
There is no native JSON parser inside OPENROWSET.

So we must use a two‑step technique:

Use the CSV parser to read the JSON file as text

Use JSON functions (JSON_VALUE or OPENJSON) to extract fields

To do this correctly, we must understand the three JSON formats used in industry.

Line‑Delimited JSON (LDJSON / NDJSON)
Definition
Each line in the file is one complete JSON document.
Lines are separated by newline characters (\n).

1. Where used
Telemetry, logs, IoT, clickstream, event‑based systems.

Example
```Code
{"id":1,"temp":22.5}
{"id":2,"temp":23.1}
{"id":3,"temp":21.9}
```
Each line is a valid JSON object.

How to read it
Use CSV parser

Override FIELDTERMINATOR and FIELDQUOTE

Use a character that will never appear in JSON

Microsoft recommends vertical tab (0x0B)

This prevents the parser from splitting JSON on commas or quotes.

2. Standard JSON (Array JSON)
Definition
Multiple JSON documents stored inside one array.

Example
```Code
[
  {"id":1,"temp":22.5},
  {"id":2,"temp":23.1},
  {"id":3,"temp":21.9}
]
```

Key point
Each line is NOT a valid JSON document.
The entire file is one JSON document.

How to read it
Read the entire file as one row

Override:

FIELDTERMINATOR = '0x0B'

FIELDQUOTE = '0x0B'

ROWTERMINATOR = '0x0B'

Then use OPENJSON to explode the array.

3. Classic / Multi‑Line JSON
Definition
Same as Standard JSON, but formatted nicely across multiple lines.

Example
```Code
[
  {
    "id": 1,
    "temp": 22.5
  },
  {
    "id": 2,
    "temp": 23.1
  }
]
```
Key point
Still one JSON array → must be read as one record.

How to read it
Same technique as Standard JSON:

Override field terminator

Override row terminator

Read entire file as one row

Use OPENJSON to extract elements

Why We Override Terminators (Critical Concept)
Problem
JSON uses commas and quotes inside the data:

```Code
{"name":"Creative Mobile Technologies, LLC"}
If we use the default CSV parser:
```
Dangerous Output

Commas split the JSON into pieces
Quotes break the parser
JSON becomes unreadable

Solution

Use a terminator that never appears in JSON:
Microsoft recommends vertical tab
Hex value: 0x0B

So we set:
```Code

FIELDTERMINATOR = '0x0B'
FIELDQUOTE      = '0x0B'
ROWTERMINATOR   = '0x0B'
```

This forces the parser to treat the entire JSON document as one column.

JSON Functions Used After Reading the File
Once the JSON text is loaded, we use SQL JSON functions.

A. JSON_VALUE()
Purpose
Extract a single scalar value from JSON.

Example

```sql
SELECT JSON_VALUE(jsonDoc, '$.id') AS id
```

Limitations
Cannot handle arrays

Cannot return objects

Inefficient for large JSON documents

B. OPENJSON()
Purpose
Explodes JSON into rows and columns.

Example: Explode an array

```sql
SELECT *
FROM OPENJSON(@jsonArray)
WITH (
    id   int        '$.id',
    temp float      '$.temp'
)
```


Strengths
Handles arrays

Handles nested objects

Efficient for large JSON

Converts JSON into tabular format

Putting It All Together
For Line‑Delimited JSON
Read file line‑by‑line

Each line becomes one JSON document

Use JSON_VALUE or OPENJSON per row

For Standard / Classic JSON
Read entire file as one row

Use OPENJSON to explode the array


Final Summary 
Serverless SQL does not have a JSON parser inside OPENROWSET.
We use the CSV parser with custom terminators to read JSON safely.
Use vertical tab (0x0B) as FIELDTERMINATOR and FIELDQUOTE to avoid breaking JSON.
Line‑delimited JSON → each line is a full JSON document.
Standard and Classic JSON → entire file is one JSON array.
Use JSON_VALUE for simple scalar extraction.
Use OPENJSON for arrays, nested objects, and full document parsing.

This approach allows Serverless SQL to handle all three JSON formats used in industry.
